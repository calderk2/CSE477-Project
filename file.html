<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
    <script>

    			var controls, camera, scene, renderer;
    			var cameraCube, sceneCube;
    			var textureCube;
    			var cubeMesh, sphereMesh;
          var reflectCubeMesh, noReflectCubeMesh;
    			var sphereMaterial;
    			var refract;

    			init();
    			animate();

    			function init() {

    				// CAMERAS

    				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );
    				camera.position.set( 0, 0, 1000 );
    				cameraCube = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );

    				controls = new THREE.OrbitControls( camera );
    				controls.minDistance = 500;
    				controls.maxDistance = 2500;

    				// SCENE

    				scene = new THREE.Scene();
    				sceneCube = new THREE.Scene();

    				// Lights

    				var ambient = new THREE.AmbientLight( 0xffffff );
    				scene.add( ambient );

    				// Textures

    				var r = "textures/lake/";
    				var urls = [ r + "posx.jpg", r + "negx.jpg",
    							 r + "posy.jpg", r + "negy.jpg",
    							 r + "posz.jpg", r + "negz.jpg" ];

    				textureCube = new THREE.CubeTextureLoader().load( urls );
    				textureCube.format = THREE.RGBFormat;
    				textureCube.mapping = THREE.CubeReflectionMapping;

    				// Materials

    				var cubeShader = THREE.ShaderLib[ "cube" ];
    				var cubeMaterial = new THREE.ShaderMaterial( {
    					fragmentShader: cubeShader.fragmentShader,
    					vertexShader: cubeShader.vertexShader,
    					uniforms: cubeShader.uniforms,
    					depthWrite: false,
    					side: THREE.BackSide
    				} );

    				cubeMaterial.uniforms[ "tCube" ].value = textureCube;

    				// Skybox

    				cubeMesh = new THREE.Mesh( new THREE.BoxBufferGeometry( 100, 100, 100 ), cubeMaterial );
    				sceneCube.add( cubeMesh );

    				//

    				var geometry = new THREE.SphereBufferGeometry( 400.0, 48, 24 );
    				sphereMaterial = new THREE.MeshLambertMaterial( { envMap: textureCube } );
    				sphereMesh = new THREE.Mesh( geometry, sphereMaterial );

    				scene.add( sphereMesh );

    				//

            var geometry = new THREE.BoxGeometry( 400, 400, 400 );
      			var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      			reflectCubeMesh = new THREE.Mesh(geometry, material);
            reflectCubeMesh.position.x = 800;
      			scene.add(reflectCubeMesh);

            //

            material = new THREE.MeshPhongMaterial({ color: 0xf00000, envMap: textureCube });
      			noReflectCubeMesh = new THREE.Mesh(geometry, material);
      			noReflectCubeMesh.position.x = -700;
      			scene.add(noReflectCubeMesh);

            //

    				renderer = new THREE.WebGLRenderer();
    				renderer.autoClear = false;
    				renderer.setPixelRatio( window.devicePixelRatio );
    				renderer.setSize( window.innerWidth, window.innerHeight );
    				document.body.appendChild( renderer.domElement );

    				window.addEventListener( 'resize', onWindowResize, false );

    			}

    			function onWindowResize() {

    				camera.aspect = window.innerWidth / window.innerHeight;
    				camera.updateProjectionMatrix();

    				cameraCube.aspect = window.innerWidth / window.innerHeight;
    				cameraCube.updateProjectionMatrix();

    				renderer.setSize( window.innerWidth, window.innerHeight );

    			}

    			//

    			function animate() {

    				requestAnimationFrame( animate );

    				render();

    			}

    			function render() {
            reflectCubeMesh.rotation.x += 0.01;
    				reflectCubeMesh.rotation.y += 0.01;
    				noReflectCubeMesh.rotation.x -= 0.03;
    				noReflectCubeMesh.rotation.y -= 0.03;

    				camera.lookAt( scene.position );
    				cameraCube.rotation.copy( camera.rotation );

    				renderer.render( sceneCube, cameraCube );
    				renderer.render( scene, camera );

    			}

    		</script>
	</body>
</html>
